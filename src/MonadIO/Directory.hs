{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE RankNTypes          #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TupleSections       #-}
{-# LANGUAGE TypeFamilies        #-}
{-# LANGUAGE UnicodeSyntax       #-}

module MonadIO.Directory
  ( chdir, indir, indirE, lsdir, lsdir', mkdir )
where

-- base --------------------------------

import Control.Monad  ( filterM, join, sequence, return )
import Data.Bool      ( Bool( True ) )
import Data.Either    ( Either( Left, Right ) )
import Data.Foldable  ( foldr )
import Data.Function  ( ($), const )
import Data.Functor   ( fmap )
import Data.List      ( sortOn )
import Data.Maybe     ( Maybe( Just, Nothing ) )
import Data.String    ( String )
import System.Exit    ( ExitCode )
import System.IO      ( IO )
import Text.Show      ( Show )

-- base-unicode-symbols ----------------

import Data.Function.Unicode  ( (‚àò) )
import Data.Monoid.Unicode    ( (‚äï) )

-- data-textual ------------------------

import Data.Textual  ( toString, toText )

-- directory ---------------------------

import System.Directory  ( listDirectory, setCurrentDirectory
                         , withCurrentDirectory )

-- exceptions --------------------------

import Control.Monad.Catch  ( bracket )

-- fpath --------------------------------

import FPath                   ( stripDir )
import FPath.AbsDir            ( AbsDir, absdir, __parseAbsDirP__ )
import FPath.AbsFile           ( AbsFile )
import FPath.AppendableFPath   ( AppendableFPath, (‚´ª) )
import FPath.AsFilePath        ( AsFilePath( filepath ) )
import FPath.Dir2              ( DirAs )
import FPath.DirType           ( DirType )
import FPath.FPath2            ( FPathAs )
import FPath.Error.FPathError  ( AsFPathError, FPathError, FPathIOError )
import FPath.Parseable         ( Parseable( __parse__, parse ) )
import FPath.RelDir            ( RelDir, reldir )
import FPath.RelFile           ( RelFile, relfile )
import FPath.RelType           ( RelType )

-- monaderror-io -----------------------

import MonadError           ( splitMError )
import MonadError2          ( ”Ç )
import MonadError.IO        ( asIOError, eitherIOThrowT )
import MonadError.IO.Error  ( AsIOError, isNoSuchThingError )

-- monadio-plus ------------------------

import MonadIO  ( MonadIO, liftIO )

-- more-unicode ------------------------

import Data.MoreUnicode.Bool     ( ùîπ )
import Data.MoreUnicode.Functor  ( (‚ä≥), (‚©∫) )
import Data.MoreUnicode.Lens     ( (‚´•) )
import Data.MoreUnicode.Monad    ( (‚™º), (‚â´) )
import Data.MoreUnicode.Natural  ( ‚Ñï )

-- mtl ---------------------------------

import Control.Monad.Except  ( ExceptT, MonadError )

-- tasty -------------------------------

import Test.Tasty  ( TestTree, testGroup )

-- tasty-hunit -------------------------

import Test.Tasty.HUnit  ( Assertion, (@?=), assertBool, testCase )

-- tasty-plus --------------------------

import TastyPlus  ( assertIOException', assertRight, runTestsP
                  , runTestsReplay, runTestTree )

-- temporary ---------------------------

import System.IO.Temp ( withSystemTempDirectory )

-- text --------------------------------

import Data.Text  ( Text )

-- unix --------------------------------

import System.Posix.Directory  ( changeWorkingDirectory, createDirectory
                               , getWorkingDirectory )
import System.Posix.Types      ( FileMode )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import MonadIO.File2  ( FileStat, IsDirectory( IsDirectory, NoIsDirectory )
                      , canRead, isdir, stat, touch )

--------------------------------------------------------------------------------

mkdir ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, DirAs Œ¥) ‚áí
        FileMode ‚Üí Œ¥ ‚Üí Œº ()
mkdir mode d = asIOError $ createDirectory (d ‚´• filepath) mode

----------------------------------------

chdir ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, DirAs Œ¥) => Œ¥ -> Œº ()
chdir d = asIOError ‚àò setCurrentDirectory $ d ‚´• filepath

----------------------------------------

indir ‚à∑ (MonadIO Œº, DirAs Œ¥) ‚áí Œ¥ ‚Üí IO Œ± ‚Üí Œº Œ±
indir d io = liftIO $ withCurrentDirectory (d ‚´• filepath) io

----------

indirE ‚à∑ (MonadIO Œº, DirAs Œ¥, MonadError Œµ Œº) ‚áí Œ¥ ‚Üí ExceptT Œµ IO Œ± ‚Üí Œº Œ±
indirE d = join ‚àò indir d ‚àò splitMError

--------------------

{- | Note that this clears up the temp directory when done. -}
intmp ‚à∑ MonadIO Œº ‚áí Text ‚Üí (AbsDir ‚Üí IO Œ±) ‚Üí Œº Œ±
intmp t io = liftIO $
  withSystemTempDirectory (toString t) $ \ d ‚Üí
    bracket (getWorkingDirectory ‚â´  \ o ‚Üí changeWorkingDirectory d ‚™º return o)
            changeWorkingDirectory
            (\ _ ‚Üí io $ __parseAbsDirP__ d)

----------

intmpE ‚à∑ (MonadIO Œº, MonadError Œµ Œº) ‚áí Text ‚Üí (AbsDir ‚Üí ExceptT Œµ IO Œ±) ‚Üí Œº Œ±
intmpE t io = join  ‚àò intmp t $ splitMError ‚àò io

----------------------------------------

toDir ‚à∑ (Parseable (DirType œÄ), AsFilePath œÄ) ‚áí œÄ ‚Üí DirType œÄ
toDir x = __parse__ (x ‚´• filepath ‚äï "/")

----------------------------------------

{- | Given a set of filenames with their stats, compile a list of files, dirs &
     errors. -}
pathTypes ‚à∑ (Parseable (DirType œÄ), AsFilePath œÄ) ‚áí
            (œÄ, Either Œµ FileStat)
          ‚Üí ([œÄ], [DirType œÄ], [(œÄ,Œµ)]) ‚Üí ([œÄ],[DirType œÄ],[(œÄ,Œµ)])

pathTypes (r, Left e) (fs, ds, es) = (fs, ds, (r,e) : es)
pathTypes (r, Right st) xs@(fs,ds,es) =
  case isdir st of
    Nothing            ‚Üí xs -- path disappeared!
    Just IsDirectory   ‚Üí (fs,toDir r:ds,es)
    Just NoIsDirectory ‚Üí (r:fs,ds,es)

----------

{- | Pair a list of files with their stat outputs. -} 
stats ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œ∑, FPathAs œÑ) ‚áí
        [œÑ] ‚Üí Œº [(œÑ, Œ∑ FileStat)]
stats fns = sequence $ fmap (\ fn ‚Üí (fn,) ‚ä≥ splitMError (stat fn)) fns

----------

{- | Partition a list of files into files, dirs & errors. -}
partnTypes ‚à∑ (MonadIO Œº, AsIOError Œµ, FPathAs œÑ, Parseable (DirType œÑ)) ‚áí
             [œÑ] ‚Üí Œº ([œÑ], [DirType œÑ], [(œÑ,Œµ)])
partnTypes = foldr pathTypes ([],[],[]) ‚©∫ stats

----------

lsdir ‚à∑ ‚àÄ Œ± Œµ Œº .
        (MonadIO Œº, AsFilePath (DirType Œ±), AppendableFPath Œ±, FPathAs Œ±,
         Parseable (DirType Œ±), RelType Œ± ~ RelFile,
         AsFPathError Œµ, AsIOError Œµ, MonadError Œµ Œº) ‚áí
        DirType Œ± ‚Üí Œº ([Œ±], [DirType Œ±], [(Œ±,Œµ)])
lsdir = lsdir' (return ‚àò const True)

----------

lsdir' ‚à∑ ‚àÄ Œ± Œµ Œº .
         (MonadIO Œº, AsFilePath (DirType Œ±), AppendableFPath Œ±, FPathAs Œ±,
          Parseable (DirType Œ±), RelType Œ± ~ RelFile,
          AsFPathError Œµ, AsIOError Œµ, MonadError Œµ Œº) ‚áí
         (Œ± ‚Üí Œº ùîπ) ‚Üí DirType Œ± ‚Üí Œº ([Œ±], [DirType Œ±], [(Œ±,Œµ)])
lsdir' p d = do
  fns ‚Üê liftIO (listDirectory (d ‚´• filepath))
  xs ‚Üê sequence $ (fmap (d ‚´ª) ‚àò parse @RelFile) ‚ä≥ fns
  ys ‚Üê filterM p xs
  partnTypes ys


--------------------

mkTestDir ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, DirAs Œ¥) => Œ¥ -> Œº ()
mkTestDir d = indirE d $ do
  mkdir 0o500 [reldir|r-x------/|]
  mkdir 0o400 [reldir|r--------/|]
  mkdir 0o100 [reldir|--x------/|]
  mkdir 0o700 [reldir|rwx------/|]
  mkdir 0o050 [reldir|---r-x---/|]
  mkdir 0o040 [reldir|---r-----/|]
  mkdir 0o010 [reldir|-----x---/|]
  mkdir 0o070 [reldir|---rwx---/|]
  touch (Just $ 0o500) [relfile|r-x|]
  touch (Just $ 0o300) [relfile|-wx|]
  touch (Just $ 0o400) [relfile|r--|]
  touch (Just $ 0o700) [relfile|rwx|]
  touch (Just $ 0o070) [relfile|---rwx|]
  return ()


----------

lsdirTests ‚à∑ TestTree
lsdirTests =
  let noSuchThing       = assertBool "isNoSuchThing" ‚àò isNoSuchThingError
      assertNoSuchThing ‚à∑ Show Œ± ‚áí IO Œ± ‚Üí Assertion
      assertNoSuchThing = assertIOException' noSuchThing

      lsdir_ ‚à∑ AbsDir ‚Üí IO ([AbsFile], [AbsDir], [(AbsFile, FPathIOError)])
      lsdir_ = eitherIOThrowT ‚àò lsdir

      listdir ‚à∑ (MonadIO Œº, MonadError Œµ Œº, AsFPathError Œµ, AsIOError Œµ) ‚áí
                Œº (AbsDir, ([AbsFile], [AbsDir], [(AbsFile, Œµ)]))
      listdir = intmpE "MonadIO.Directory" $ \ d ‚Üí do
        mkTestDir d
        (d,) ‚ä≥ lsdir d
      listdir' ‚à∑ IO (Either FPathIOError
                            (AbsDir,
                                 ([AbsFile],[AbsDir],[(AbsFile,FPathIOError)])))
      listdir' = splitMError listdir

      listdirr ‚à∑ (MonadIO Œº, MonadError Œµ Œº, AsFPathError Œµ, AsIOError Œµ) ‚áí
                 Œº (AbsDir, ([AbsFile], [AbsDir], [(AbsFile, Œµ)]))
      listdirr = intmpE "MonadIO.Directory" $ \ d ‚Üí do
        mkTestDir d
        (d,) ‚ä≥ lsdir' canRead d
      listdirr' ‚à∑ IO (Either FPathIOError
                             (AbsDir,
                                 ([AbsFile],[AbsDir],[(AbsFile,FPathIOError)])))
      listdirr' = splitMError listdirr

      -- strip the /tmp/‚Ä¶ prefix and sort for test determinism
      stripDir_ d = ”Ç ‚àò stripDir @_ @FPathError d
      strip ‚à∑ (AbsDir, ([AbsFile], [AbsDir], Œ±)) -> ([RelFile], [RelDir], Œ±)
      strip (p, (fs,ds,z)) = (sortOn toText $ stripDir_ p ‚ä≥ fs,
                              sortOn toText $ stripDir_ p ‚ä≥ ds, z)

      expFiles = [ [relfile|---rwx|], [relfile|-wx|], [relfile|r--|]
                 , [relfile|r-x|] , [relfile|rwx|] ]
      expDirs  = [ [reldir|-----x---/|], [reldir|---r-----/|]
                 , [reldir|---r-x---/|], [reldir|---rwx---/|]
                 , [reldir|--x------/|], [reldir|r--------/|]
                 , [reldir|r-x------/|], [reldir|rwx------/|]
                 ]
      -- only those things that should be returned by listDirReadable; that is,
      -- owner-readable files, owner-readable-and-executable dirs
      expFilesR = [ [relfile|r--|], [relfile|r-x|] , [relfile|rwx|] ]
      expDirsR  = [ [reldir|r--------/|], [reldir|r-x------/|]
                  , [reldir|rwx------/|] ]
  

   in testGroup "listDir"
        [ testCase "nonesuch" $ assertNoSuchThing(lsdir_ [absdir|/nonesuch/|])
        , testCase "listDir isRight" $
            listdir' ‚â´ assertRight (assertBool "isRight" ‚àò const True)
        , testCase "listDir"  $
            fmap (strip ‚ä≥) listdir' ‚â´ (@?= Right (expFiles, expDirs, []))

        , testCase "listDirReadable"  $
            fmap (strip ‚ä≥) listdirr' ‚â´ (@?= Right (expFilesR, expDirsR, []))

        ]

--------------------------------------------------------------------------------
--                                   tests                                    --
--------------------------------------------------------------------------------

tests ‚à∑ TestTree
tests = testGroup "Directory" [ lsdirTests ]
                
----------------------------------------

_test ‚à∑ IO ExitCode
_test = runTestTree tests

--------------------

_tests ‚à∑ String ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ String ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
